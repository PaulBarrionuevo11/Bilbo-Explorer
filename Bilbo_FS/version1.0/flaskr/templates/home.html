{% extends "base.html" %}

{% block title %}Home{% endblock %}

{% block content %}
<div class="charts-row">
    <div class="chart-container">
        <canvas id="sensorChart1"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="sensorChart2"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="sensorChart3"></canvas>
    </div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
<script>
    // Function to format time as HH:mm:ss
    function formatTime(date) {
        const hours = String(date.getHours()).padStart(2, '0');
        const minutes = String(date.getMinutes()).padStart(2, '0');
        const seconds = String(date.getSeconds()).padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    }

    // Simulate sensor data (fallback)
    function simulateSensorData(canvasId) {
        if (canvasId === 'sensorChart1') return Math.random() * 1000 + 500; // Altitude: 500-1500m
        if (canvasId === 'sensorChart2') return Math.random() * 2 - 1; // IMU: -1 to 1 (e.g., acceleration)
        return Math.random() * 20 + 20; // Baro temp: 20-40°C
    }

    // Initialize chart with pre-populated data
    function initializeChart(canvasId, chartType, label, color, background) {
        const ctx = document.getElementById(canvasId).getContext('2d');
        const maxDataPoints = 20;
        const now = new Date();
        const labels = [];
        const data = [];

        // Pre-populate with 20 points (t-38s to t-0s)
        for (let i = 19; i >= 0; i--) {
            const pastTime = new Date(now.getTime() - (i * 2000));
            labels.push(formatTime(pastTime));
            data.push(simulateSensorData(canvasId));
        }

        return new Chart(ctx, {
            type: chartType,
            data: {
                labels: labels,
                datasets: [{
                    label: label,
                    data: data,
                    borderColor: color,
                    backgroundColor: background,
                    pointBackgroundColor: color,
                    pointBorderColor: color,
                    fill: true,
                    tension: 0.4
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: {
                            display: true,
                            // text: 'Time (HH:mm:ss)',
                            color: '#FFFCFB'
                        },
                        ticks: {
                            color: '#EAEFEF'
                        },
                        grid: {
                            color: '#666666'
                        }
                    },
                    y: {
                        title: {
                            display: true,
                            // text: yAxisLabel,
                            color: '#FFFCFB'
                        },
                        ticks: {
                            color: '#FFFCFB'
                        },
                        grid: {
                            color: '#666666'
                        },
                        beginAtZero: false
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        labels: {
                            color: '#FFFCFB'
                        }
                    }
                }
            }
        });
    }

    // Initialize three charts with unique colors and y-axis labels
    const sensorChart1 = initializeChart('sensorChart1', 'bar', 'Altitude (m)', '#77BEF0', '#77BEF0');
    const sensorChart2 = initializeChart('sensorChart2', 'line', 'IMU (g)', '#77BEF0', 'rgba(0, 123, 255, 0.1)');
    const sensorChart3 = initializeChart('sensorChart3', 'line', 'Baro temp (°C)', '#4A9782', 'rgba(40, 167, 69, 0.1)');

    // Update chart with new data
    function updateChart(chart, value) {
        const now = new Date();
        chart.data.labels.push(formatTime(now));
        chart.data.datasets[0].data.push(value);

        // Remove oldest data if exceeding maxDataPoints
        if (chart.data.labels.length > 20) {
            chart.data.labels.shift();
            chart.data.datasets[0].data.shift();
        }

        chart.update();
    }

    // WebSocket connections with fallback to simulated data
    function setupWebSocket(chart, wsUrl, chartId) {
        try {
            const ws = new WebSocket(wsUrl);
            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                updateChart(chart, data.value);
            };
            ws.onerror = function(error) {
                console.error(`WebSocket error for ${chartId}:`, error);
                setInterval(() => updateChart(chart, simulateSensorData(chartId)), 2000);
            };
            ws.onclose = function() {
                console.warn(`WebSocket closed for ${chartId}, using simulated data`);
                setInterval(() => updateChart(chart, simulateSensorData(chartId)), 2000);
            };
        } catch (error) {
            console.error(`WebSocket setup failed for ${chartId}:`, error);
            setInterval(() => updateChart(chart, simulateSensorData(chartId)), 2000);
        }
    }

    // Replace with your actual WebSocket URLs
    setupWebSocket(sensorChart1, 'ws://sensor1-websocket-url', 'sensorChart1');
    setupWebSocket(sensorChart2, 'ws://sensor2-websocket-url', 'sensorChart2');
    setupWebSocket(sensorChart3, 'ws://sensor3-websocket-url', 'sensorChart3');
</script>
{% endblock %}